# Go の Goroutine を使ったサンプル

## 概要

このプロジェクトは、Go の `goroutine` を使って並列処理を実行する方法を示します。`go` キーワードを使った並列処理の基本を理解し、適切に制御する方法を学びます。

## `goroutine` とは？

`goroutine` は、Go 言語が提供する軽量なスレッドのような仕組みです。通常の関数呼び出しの前に `go` キーワードを付けることで、新しい `goroutine` として並列実行できます。

### 学んだポイント

- **goroutine の作成**: `go 関数名()` を使って並列処理を開始。
- **並列処理の非同期実行**: goroutine はメイン処理とは独立して実行される。
- **メイン関数の終了による goroutine の影響**: メイン関数が終了すると、実行中の goroutine も終了してしまう。
- **`time.Sleep()` の活用**: goroutine が終了する前にメイン関数を維持するための一時的な手段。
- **`sync.WaitGroup` の活用**: `goroutine` の完了を適切に待つための手段。
- **`defer` の活用**: `WaitGroup` を適切に管理し、処理の終了を保証。
- **複数のワーカーを並列実行する方法**: `for` ループで `goroutine` を複数起動し、チャネル (`chan`) を通じてジョブを分配する。
- **`for job := range ch` の動作**: チャネルのデータをすべて処理し、`close(ch)` されるとループを抜ける。
- **バッファ付きチャネルの動作 (`make(chan int, N)`)**: バッファが満杯になると、ワーカーが処理するまで送信側 (`jobQueue <- j`) はブロックされる。
- **チャネルを閉じる (`close(ch)`) 重要性**: `close(ch)` しないとワーカーが無限に待機し続ける。
- **エラーチャネル (`chan error`) の活用**: ワーカーがエラーを発生させた場合、チャネルを使ってエラーを安全に収集し、処理できる。
- **`for err := range errorChan` の動作**: チャネル内のエラーをすべて処理し、`close(errorChan)` されるとループを抜ける。

### **実行方法**

```sh
go run main.go  # goroutine を使った並列処理の実行
```

## **学習ポイント**

1. **`go` キーワードを使うことで関数を並列実行できる**
2. **メイン関数が終了すると、goroutine も強制終了する**
3. **`time.Sleep()` は goroutine を維持するための一時的な方法だが、適切な方法ではない**
4. **`sync.WaitGroup` を使うことで、goroutine が完了するまでメイン関数の終了を待つことができる**
5. **`defer wg.Done()` を使うことで goroutine の終了時にカウントを適切に減らすことができる**
6. **チャネル (`chan`) を使うことで、goroutine 同士が安全にデータを受け渡せる**
7. **`close(jobQueue)` を適切に行うことで、goroutine の終了を制御できる**
8. **バッファ付きチャネルの仕組みを理解し、ブロッキングの挙動を学ぶ**
9. **ワーカーを複数並列に起動し、ジョブを分配する方法を学ぶ**
10. **ワーカー内でエラーが発生した際に `errorChan` を通じてエラーを収集し、後から処理する方法を学ぶ**
11. **`close(errorChan)` を適切に行うことで、エラーチャネルの `range` ループが正常に終了する仕組みを理解する**

## 作成者

- **池田虎太郎** | [GitHub プロフィール](https://github.com/kotaroikeda-apl-dev)
